# Story 1.1: Project Setup & Clean Architecture

## Status
Approved

## Story

**As a** developer,  
**I want** a well-organized .NET 8 project with clean architecture layers,  
**so that** I can build features following established patterns and maintain code quality throughout the project.

## Acceptance Criteria

1. .NET 8 project created with folder structure: `/API`, `/Application`, `/Domain`, `/Infrastructure`
2. Each layer has clear responsibility: Domain (entities, domain logic), Application (services, DTOs), Infrastructure (DB, external services), API (controllers, middleware)
3. Dependency injection configured in .NET DI container (Program.cs)
4. SOLID principles demonstrated (e.g., interfaces for services, no cross-layer dependencies)
5. Global exception handler middleware in place (catches errors and returns standard error responses)
6. Logging configured (Serilog) and integrated into startup
7. API returns structured responses with consistent error format (code, message, statusCode)
8. GitHub repo initialized with .gitignore configured for .NET projects
9. Local development can run with `dotnet run` without configuration

## Tasks / Subtasks

- [ ] **Task 1: Initialize .NET 8 Project Structure** (AC: 1, 2)
  - [ ] Create solution file: `SmartScheduler.sln`
  - [ ] Create four class libraries:
    - [ ] `SmartScheduler.Domain` - Entities, domain logic, value objects
    - [ ] `SmartScheduler.Application` - Services, DTOs, business logic orchestration
    - [ ] `SmartScheduler.Infrastructure` - Database access, external services, repositories
    - [ ] `SmartScheduler.API` - Controllers, middleware, Program.cs, appsettings
  - [ ] Set up project dependencies: API → Application → Domain; Infrastructure → Domain
  - [ ] Ensure no circular dependencies (verify with Architecture Dependency Analyzer if possible)

- [ ] **Task 2: Configure Dependency Injection** (AC: 3, 4)
  - [ ] Create extension methods in each layer (`DomainServiceExtensions`, `ApplicationServiceExtensions`, `InfrastructureServiceExtensions`)
  - [ ] Register all services in `Program.cs` using DI container
  - [ ] Implement interface-based service design (e.g., `IContractorService`, `IJobService`)
  - [ ] Verify no service directly depends on another layer (only through interfaces)

- [ ] **Task 3: Set Up Logging with Serilog** (AC: 6)
  - [ ] Install Serilog NuGet package
  - [ ] Configure Serilog in `Program.cs` with structured logging (JSON format)
  - [ ] Configure log output: Console (dev), CloudWatch (production, deferred)
  - [ ] Add request ID correlation (for tracking API calls through layers)
  - [ ] Create `LoggingExtensions.cs` for common logging patterns

- [ ] **Task 4: Implement Global Exception Handler Middleware** (AC: 5, 7)
  - [ ] Create `ExceptionHandlingMiddleware` class in API layer
  - [ ] Implement exception mapping to structured error responses:
    - [ ] Format: `{ error: { code: "ERROR_CODE", message: "User-friendly message", statusCode: 400 } }`
    - [ ] Examples:
      - [ ] `ValidationException` → 400 (Bad Request)
      - [ ] `UnauthorizedException` → 401 (Unauthorized)
      - [ ] `ForbiddenException` → 403 (Forbidden)
      - [ ] `NotFoundException` → 404 (Not Found)
      - [ ] `ConflictException` → 409 (Conflict)
      - [ ] Generic `Exception` → 500 (Internal Server Error)
  - [ ] Register middleware in `Program.cs` pipeline (first, before routing)
  - [ ] Log all exceptions with request context (request ID, user ID, timestamp)

- [ ] **Task 5: Create Structured Response Model** (AC: 7)
  - [ ] Create `ApiResponse<T>` generic class in Application layer
  - [ ] Implement `ApiErrorResponse` for errors
  - [ ] Add extension methods: `Ok<T>()`, `Created<T>()`, `BadRequest()`, etc. for controllers
  - [ ] All API endpoints return wrapped responses (not raw DTOs)

- [ ] **Task 6: Set Up appsettings Configuration** (AC: 1)
  - [ ] Create `appsettings.json` with default values
  - [ ] Create `appsettings.Development.json` for local dev (no secrets hardcoded)
  - [ ] Configure connection string placeholder (DB connection handled in Story 1.2)
  - [ ] Configure Serilog settings (log level, output format)
  - [ ] Document required environment variables for production

- [ ] **Task 7: Initialize GitHub Repository & .gitignore** (AC: 8)
  - [ ] Initialize git repository at project root
  - [ ] Create `.gitignore` configured for .NET projects (exclude bin/, obj/, *.user, appsettings.Production.json, etc.)
  - [ ] Create initial commit: "feat: initialize .NET 8 solution with clean architecture"
  - [ ] Verify no secrets or sensitive files committed

- [ ] **Task 8: Verify Clean Architecture & Local Execution** (AC: 1, 4, 9)
  - [ ] Run `dotnet run` from API project folder → server starts on http://localhost:5000
  - [ ] Test health check endpoint: `GET /health` → returns 200 OK with simple JSON response
  - [ ] Verify all layers load without errors (no missing dependencies)
  - [ ] Create `HealthCheckController` as proof of clean architecture working

- [ ] **Task 9: Unit Tests for Architecture** (AC: 4)
  - [ ] Create `SmartScheduler.API.Tests` xUnit project
  - [ ] Test DI container: All registered services resolve correctly
  - [ ] Test exception middleware: Various exception types → correct HTTP status codes
  - [ ] Test response wrapper: `ApiResponse<T>` serializes correctly to JSON
  - [ ] Verify architecture rules: No Application layer references Infrastructure directly

## Dev Notes

### Previous Story Insights
None - this is Story 1.1 (first story).

### Project Structure & Folder Layout
The project structure follows clean architecture principles:
- **Domain Layer** (`SmartScheduler.Domain/`):
  - Contains business entities and domain logic
  - No external dependencies (no EF Core, no HTTP clients)
  - Entities: User, Contractor, Customer, Job, Assignment, Review, etc. (defined in Story 1.2)
  
- **Application Layer** (`SmartScheduler.Application/`):
  - Contains business services and DTOs
  - Interfaces for repositories (implementations in Infrastructure)
  - MediatR commands/queries (CQRS pattern)
  - FluentValidation validators
  - Mapper configurations (AutoMapper)
  
- **Infrastructure Layer** (`SmartScheduler.Infrastructure/`):
  - Database context (EF Core DbContext)
  - Repository implementations (Story 1.2)
  - External service implementations (Google Maps, AWS SES)
  - Configuration for third-party services
  
- **API Layer** (`SmartScheduler.API/`):
  - Controllers (one per feature: ContractorsController, JobsController, etc.)
  - Middleware (exception handling, logging, auth)
  - Program.cs (DI configuration, pipeline setup)
  - appsettings.json configuration files

[Source: architecture/12-unified-project-structure.md]

### Dependency Injection Pattern
Use ASP.NET Core's built-in DI container (no third-party DI container needed):
- Register each layer's services in `Program.cs` via extension methods
- Follow convention: `app.AddDomainServices()`, `app.AddApplicationServices()`, `app.AddInfrastructureServices()`
- All services registered as interfaces (not concrete types) to enable testing and loose coupling
- Example:
  ```csharp
  // In Program.cs
  builder.Services.AddDomainServices();
  builder.Services.AddApplicationServices();
  builder.Services.AddInfrastructureServices(builder.Configuration);
  builder.Services.AddControllers();
  ```

[Source: architecture/17-coding-standards.md]

### Logging Configuration
Use Serilog for structured logging:
- Structured JSON logs enable CloudWatch Insights queries (Phase 2)
- Include request ID correlation: Every HTTP request gets a unique RequestId (from headers or generated)
- Log level defaults:
  - Development: `Information` (see most logs)
  - Production: `Warning` (minimize noise)
- Serilog sinks:
  - Console (development and production)
  - CloudWatch (production only, deferred to Phase 2)

Example Serilog setup in Program.cs:
```csharp
Log.Logger = new LoggerConfiguration()
    .MinimumLevel.Information()
    .WriteTo.Console(new CompactJsonFormatter())
    .Enrich.FromLogContext() // Enables request ID correlation
    .Enrich.WithProperty("Environment", env.EnvironmentName)
    .CreateLogger();
```

[Source: architecture/3-tech-stack.md (Serilog v8.0.3)]

### Exception Handling Middleware
The global exception handler intercepts all unhandled exceptions and returns structured error responses:
- All exceptions logged with full context (stack trace, request details, user ID)
- User-facing error message (safe, no stack traces exposed)
- HTTP status codes strictly followed (400, 401, 403, 404, 409, 500)
- Example custom exceptions:
  ```csharp
  // Domain/Exceptions/DomainException.cs
  public class DomainException : Exception { }
  public class NotFoundException : DomainException { }
  public class UnauthorizedException : DomainException { }
  public class ForbiddenException : DomainException { }
  public class ValidationException : DomainException { }
  public class ConflictException : DomainException { }
  ```

[Source: architecture/18-error-handling-strategy.md]

### API Response Format
All endpoints return wrapped JSON responses:
```csharp
// Success response
{
  "success": true,
  "data": { /* entity or DTO */ },
  "statusCode": 200
}

// Error response
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Email must be valid",
    "statusCode": 400
  }
}
```

This enables consistent frontend error handling and clear API contracts. [Source: architecture/5-api-specification.md]

### Testing Standards for This Story
**Test Framework:** xUnit + FluentAssertions + Moq  
**Test Location:** `SmartScheduler.API.Tests/` folder (mirroring project structure)  
**Testing Patterns:**
- Arrange-Act-Assert (AAA) pattern
- One assertion per unit test (ideally)
- Test names describe behavior: `POST_CreateContractor_WithValidData_ReturnsCreated()`
- Use FluentAssertions for readable assertions: `.Should().Be()`, `.Should().Throw<>()`
- Mock external dependencies (repositories, services) using Moq

**Specific Tests for Story 1.1:**
- DI container tests: Verify all services resolve without errors
- Exception handler tests: Verify each exception type returns correct HTTP status
- API response wrapper tests: Verify JSON serialization
- Architecture rules tests: No cross-layer violations

[Source: architecture/16-testing-strategy.md]

### Naming Conventions
Follow .NET conventions:
- **Project names:** PascalCase (e.g., `SmartScheduler.Domain`, `SmartScheduler.API`)
- **Namespaces:** Match folder structure (e.g., `SmartScheduler.Application.Services`)
- **Classes/Interfaces:** PascalCase (e.g., `ContractorService`, `IContractorRepository`)
- **Constants:** SCREAMING_SNAKE_CASE (e.g., `MAX_RECOMMENDATIONS = 5`)
- **Database tables:** PascalCase (e.g., `Contractors`, `Jobs`)

[Source: architecture/17-coding-standards.md]

### Tech Stack Specifics for This Story
- **Language:** C# 12.0 (ships with .NET 8)
- **Framework:** ASP.NET Core 8.0.21
- **Logging:** Serilog 8.0.3
- **Validation:** FluentValidation 11.11.0
- **Testing:** xUnit 2.9.2 + FluentAssertions 6.12.2 + Moq 4.20.72
- **IDE Build:** Visual Studio 2022 or Visual Studio Code + Omnisharp

[Source: architecture/3-tech-stack.md]

## Testing

### Testing Framework & Location
- **Framework:** xUnit + FluentAssertions + Moq
- **Test Project:** `SmartScheduler.API.Tests/`
- **Test File Naming:** `{ComponentName}Tests.cs` (e.g., `ExceptionHandlingMiddlewareTests.cs`, `DependencyInjectionTests.cs`)

### Testing Requirements for This Story
1. **DI Container Tests:**
   - Verify all layers register services without errors
   - Test that main API service (e.g., IContractorService) resolves correctly
   - Assert no circular dependencies
   
2. **Exception Handler Tests:**
   - Test middleware catches exceptions and returns correct status codes
   - Test each exception type (NotFoundException → 404, ValidationException → 400, etc.)
   - Verify error response format includes code, message, statusCode
   
3. **Response Wrapper Tests:**
   - Test ApiResponse<T> serializes to correct JSON
   - Test ApiErrorResponse includes code, message, statusCode
   
4. **Architecture Rules Tests:**
   - Verify Application layer doesn't directly reference Infrastructure (only via interfaces)
   - Verify no circular dependencies between layers

### Running Tests Locally
```bash
cd backend/SmartScheduler.API.Tests
dotnet test
```

Expected output:
```
Passed! - Failed: 0, Passed: X, Skipped: 0
```

[Source: architecture/16-testing-strategy.md]

## Change Log

| Date        | Version | Description                              | Author |
|-------------|---------|------------------------------------------|--------|
| Nov 7, 2025 | 1.0     | Initial story draft created               | Bob (Scrum Master) |
| Nov 7, 2025 | 1.1     | Story validated and approved              | Bob (Scrum Master) |

---

## Story Validation Summary

✅ **READY FOR IMPLEMENTATION**

**Validation Result:** PASS (5/5 categories)
- Clarity Score: 9/10
- Goal & Context: PASS ✅
- Technical Guidance: PASS ✅
- Reference Effectiveness: PASS ✅
- Self-Containment: PASS ✅
- Testing Guidance: PASS ✅

**Key Strengths:**
- Clear project structure with 4-layer clean architecture
- Comprehensive tasks with actionable subtasks
- Detailed technical guidance with code examples
- Self-contained with proper source references
- Testable acceptance criteria
- No blocking dependencies

**Recommended Pre-Implementation Steps:**
- Dev agent: Review `docs/architecture/3-tech-stack.md` for technology rationale
- Dev agent: Review `docs/architecture/12-unified-project-structure.md` for folder structure details
- Dev agent: Review `docs/architecture/17-coding-standards.md` for naming conventions

---

## Dev Agent Record

*This section is populated by the development agent during implementation.*

### Agent Model Used
*To be filled during implementation*

### Debug Log References
*To be filled during implementation*

### Completion Notes
*To be filled during implementation*

### File List
*To be filled during implementation*

---

## QA Results

*This section is populated by QA agent after implementation.*

